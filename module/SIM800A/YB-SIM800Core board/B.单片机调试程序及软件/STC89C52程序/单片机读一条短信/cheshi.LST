C51 COMPILER V7.50   CHESHI                                                                03/28/2011 00:32:41 PAGE 1   


C51 COMPILER V7.50, COMPILATION OF MODULE CHESHI
OBJECT MODULE PLACED IN cheshi.OBJ
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE cheshi.C BROWSE DEBUG OBJECTEXTEND

line level    source

   1          //==**********************************************************
   2          //--软件功能, 读一条短信，但不回复，
   3          //---   可使用单片机  要求 16K ROM 256 RAM 及以上 8位标准单片机   STC SST SM W78E单片机
   4          //--   TC35 SIM300 GTM900 EM310   波特率 9600
   5          //100%不支持  AT89S51 W78E51及其它RAM为 128B的单片机
   6          //============================================================
   7          #include <cheshi.h>
   8          //#include <lcd.h>
   9          uchar data int_case;    //中断标志
  10          #define MAX_TM   100         // AT指收发数组最大缓冲
  11          #define MAX_T  35
  12          uchar idata uart_buff[MAX_TM]; //通信程序中的缓冲
  13          uchar idata  receive_count;    //发送与接收 数组指针
  14          
  15          uchar data para_temp[MAX_T];     //多用临时用
  16          uchar data read_tmp;             ///读电话本号参数
  17          uchar data sms_num_tmp;                 ///读短信号码参数
  18          uchar data sms_tmp;                     ///短信处理参数代码
  19          uchar idata TEL_temp[15];   //存对方号码，
  20          #define IO_OUT                  P3_6
  21          
  22          
  23          //－－－定时用－－－－－－－－－－－
  24          uint  data timercount;          //50MS定时器,
  25          uchar data timer_1S_cnt;
  26          uchar data timer_10S_cnt;
  27          uchar data timer_S_cnt;
  28          //--------------------
  29          uchar data ring_cnt;    //振铃用
  30           bit ring_bit  ;  // 电话呼入　2
  31          
  32          
  33          
  34          
  35          
  36            /*
  37          *********************************************************************************************************
  38          ** 函数名称 dmsec()
  39          ** 函数功能 ：延时 NS
  40          ** 入口参数 ：
  41          ** 出口参数 :
  42          *********************************************************************************************************
  43          */
  44          //---延时S------------------------------
  45          void dmsec (unsigned int count)
  46          {
  47   1              unsigned int i;
  48   1              while (count)
  49   1              {
  50   2                      #if   CPU_TYPE2==W78E58
  51   2                 i =115;
  52   2              #elif  CPU_TYPE2==STC89E58
                         i =300;
                      #endif
  55   2      
C51 COMPILER V7.50   CHESHI                                                                03/28/2011 00:32:41 PAGE 2   

  56   2                      while (i>0) i--;
  57   2                      count--;
  58   2          }
  59   1      }
  60          
  61          
  62          //------------------------
  63          //----------------------
  64          /*
  65          *********************************************************************************************************
  66          ** 函数名称     Int_Timer0()
  67          ** 函数功能             定时器中断位,是整个程序的心跳,如果停止,程序会死机
  68          ** 全局变量或数组:
  69          
  70          ** 入口参数      ：
  71          ** 出口参数     ：
  72          *********************************************************************************************************
  73          */
  74          
  75          void  Int_Timer0(void) interrupt 1 using 3
  76          {
  77   1           TH0 = 0xB8;
  78   1               TL0 = 0x00; //20ms的时钟基准
  79   1      
  80   1         timer_1S_cnt++;   timercount++;
  81   1         if(timer_1S_cnt==50)    //20×50=1000MS  =1S
  82   1          { timer_10S_cnt++; timer_1S_cnt=0;
  83   2            timer_S_cnt++;
  84   2                LED_S0=~LED_S0;
  85   2      
  86   2          }                              //１秒＝１０００毫秒
  87   1          if(timer_10S_cnt==60)   //60S
  88   1          {
  89   2                 timer_10S_cnt=0;
  90   2      
  91   2              }
  92   1      
  93   1      //---------------------------------------------------------------------------------
  94   1      
  95   1      }
  96          
  97          /*
  98          *********************************************************************************************************
  99          ** 函数名称     Int_Uart()
 100          ** 函数功能              TC35 的命令列表,与中断服务程序
 101          ** 全局变量或数组:   receive_count 接收指针      uart_buff
 102                                ring_bit  ring_cnt
 103          ** 入口参数      ：
 104          ** 出口参数     ： 1-成功      0-失败
 105          *********************************************************************************************************
 106          */
 107          
 108          void  Int_Uart(void) interrupt 4 using 3  //串口的中断程序
 109          {
 110   1      
 111   1              if(RI) //命令方式
 112   1          {
 113   2      
 114   2                      RI=0;
 115   2      
 116   2               if((receive_count<MAX_TM-1))//没有发送时才能进行接收
 117   2                      {       //所有的命令返回都是处于 0x0A [Result] 0x0D 之间,其他命令,不会出现这种情况
C51 COMPILER V7.50   CHESHI                                                                03/28/2011 00:32:41 PAGE 3   

 118   3                      uart_buff[receive_count++]=SBUF;
 119   3                     //0D 0A 32 0D 0A
 120   3                      if((receive_count==5)&&(uart_buff[0]==0x0d&&uart_buff[1]==0x0A))
 121   3                      {
 122   4                         if(uart_buff[2]=='2')    //电话呼入
 123   4                                 {    ring_bit=1;  ring_cnt++;
 124   5                                     receive_count=0;
 125   5                                 }
 126   4                      }
 127   3                      }
 128   2                       else
 129   2                       {
 130   3                               return;
 131   3                       }
 132   2      
 133   2      
 134   2            //------------------------------------
 135   2      
 136   2              }//End of if(RI)
 137   1      }
 138          
 139          /*********************************************************************
 140           *                  C51中字符串函数的扩充                            *
 141           ** 函数名称    : strsearch ()
 142           ** 函数功能    : 在指定的数组里连续找到相同的内容
 143           ** 入口参数   ： ptr2=要找的内容, ptr1 当前数组
 144           **** 出口参数 ： 0-没有 找到   >1 查找到
 145           *********************************************************************/
 146          
 147          
 148          uchar strsearch(uchar *ptr2,uchar *ptr1_at)//查字符串*ptr2在*ptr1中的位置
 149          //本函数是用来检查字符串*ptr2是否完全包含在*ptr1中
 150          //返回:  0  没有找到
 151          //       1-255 从第N个字符开始相同
 152          {
 153   1      //、    uchar max_length;
 154   1              uchar i,j,k;
 155   1              uchar flag;
 156   1              if(ptr2[0]==0) return(0);
 157   1              flag=0;
 158   1              for(i=0,j=0;i<MAX_TM-2;i++)
 159   1              {
 160   2              if(ptr1_at[i]==ptr2[j])
 161   2              {//第一个字符相同
 162   3                      k=i;
 163   3                      //for(k=i;k<MAX_TM-2;k++,j++)
 164   3                      do {
 165   4                              if(ptr2[j]==0)//比较正确
 166   4                                      return(i+1);               //返回值是整数，不含0
 167   4                              if(ptr1_at[k]!=ptr2[j]) break;
 168   4                              k++;j++ ;
 169   4                      } while(k<MAX_TM-2) ;
 170   3      
 171   3                      j=0;
 172   3              }
 173   2              }
 174   1              return(0);
 175   1      }
 176          
 177          /*********************************************************************
 178           *                  C51中字符串函数的扩充                            *
 179           ** 函数名称    : strsearch1()
C51 COMPILER V7.50   CHESHI                                                                03/28/2011 00:32:41 PAGE 4   

 180           ** 函数功能    : 在指定的数组里连续找到相同的内容
 181           ** 入口参数   ： ptr2=要找的内容, ptr1 当前数组, id 数组开始的第一个位置
 182           **** 出口参数 ： 0-没有 找到   >1 查找到
 183           *********************************************************************/
 184          //------在指定移态的数组里连续找到相同的内容---------------------------------------
 185          //i=传来的指令,  *ptr2=要找的内容, uchar *ptr1 当前数组
 186          uchar strsearch1(uchar i,uchar *ptr2,uchar *ptr1)
 187          {      uchar j=0,k;
 188   1                              k=i;
 189   1            do{
 190   2                      if(ptr1[k]==ptr2[j])
 191   2                      {j++;k++;}
 192   2                      else return(0);
 193   2                      if(ptr2[j]==0)  return(k);
 194   2              }while(j<=60);
 195   1              return(0xff);
 196   1      }
 197          
 198          
 199          
 200          /*
 201          *********************************************************************************************************
 202          ** 函数名称      CMGD_GSM()
 203          ** 函数功能               删除短信   uart_buff
 204          ** 全局变量或数组:   uart_buff   sms_num_tmp
 205          ** 入口参数      ：  AT指令 字符串
 206                                  *str_at=要复制的内容/转AT指令
 207                              id    短信ID  供删除短信时用
 208          ** 出口参数     ：
 209          *********************************************************************************************************
 210          */
 211          //----------------------------------
 212          //删除短信   uart_buff
 213          void CMGD_GSM(char* ptr1_at,uchar id)
 214          {
 215   1               uchar  ptr1[3] ;
 216   1              ptr1[0]=(id/10)+0x30;
 217   1              ptr1[1]=(id%10)+0x30;
 218   1              ptr1[2]=0;
 219   1                Send_AT_Command(SMS_CMGD,ptr1_at,ptr1);    //删除其它没有用的短信
 220   1                Send_AT_Command(SMS_CMGD,ptr1_at,ptr1);
 221   1      
 222   1      
 223   1      }
 224          
 225          /*
 226          *********************************************************************************************************
 227          ** 函数名称      CPMS_SM()
 228          ** 函数功能               功能 读短信报文 ,有短信就读短信 ,把有短信的ID找到,并读出内容
 229          ** 全局变量或数组:   receive_count 接收指针  uart_buff  sms_num_tmp
 230          ** 入口参数      ：  AT指令 字符串
 231                                  *str_at=要复制的内容/转AT指令
 232                              sms_num_tmp     短信ID  供删除短信时用
 233          
 234          ** 出口参数     ： 1-成功      0-失败
 235          *********************************************************************************************************
 236          */
 237          
 238          uchar CPMS_SM(char* ptr1_at )
 239          //----------------------
 240          {   uchar i,j,r,num_tmp1;
 241   1            Send_AT_Command(AT_INIT,ptr1_at,0);
C51 COMPILER V7.50   CHESHI                                                                03/28/2011 00:32:41 PAGE 5   

 242   1            Send_AT_Command(AT_E,ptr1_at,0);
 243   1            Send_AT_Command(AT_CPMS,ptr1_at,0);
 244   1            if(i=strsearch("+CPMS:",ptr1_at)) //"SM"  +CPMS: 0,20,0,45,0,45
 245   1                               { i=i+5;
 246   2                                   //+CPMS: 0,20,0,45,0,45
 247   2                                if(strsearch1(i,"\x20\x30,",ptr1_at))  //没有短信
 248   2                               {     return(0);
 249   3                               }
 250   2                                else  if((ptr1_at[i]==' ')&&((ptr1_at[i+1]>'1')  //9以下短信处理
 251   2                                          &&(ptr1_at[i+1]<='9'))&&(ptr1_at[i+2]==','))
 252   2                             {      //+CPMS: 1,20,1,20,1,20
 253   3                                 i=i+1;
 254   3                                         r=ptr1_at[i]-0x30;   //有几个短个
 255   3                                         i++;//,
 256   3                                         i++; //20
 257   3                                         j=0;
 258   3                                         j=ptr1_at[i]-0x30;
 259   3                                         j=j*10; //高位
 260   3                                         i++;
 261   3                                         j=j+(ptr1_at[i]-0x30); //低位
 262   3                                         i++;
 263   3                                         if(ptr1_at[i]!=','&&ptr1_at[i+1]==',') //可以存100以上的
 264   3                                         { j=j*10;i++;
 265   4                                           j=j+(ptr1_at[i]-0x30);
 266   4      
 267   4                                        }
 268   3                       //返回是可以存多少短信
 269   3                                        //r=j+10;
 270   3                               }
 271   2                                else if((ptr1_at[i]==' ')&&((ptr1_at[i+1]>'0')  //10条短信以上处理
 272   2                                          &&(ptr1_at[i+2]>='0'))&&(ptr1_at[i+3]==','))
 273   2                             {
 274   3                                 i=i+1;
 275   3                                         r=ptr1_at[i++]-0x30;
 276   3                                         r=r*10;   //移到十位
 277   3                                         r=r+ptr1_at[i++]-0x30;
 278   3      
 279   3                                         i++; //20
 280   3                                         j=0;
 281   3                                         j=ptr1_at[i]-0x30;
 282   3                                         j=j*10; //高位
 283   3                                         i++;
 284   3                                         j=j+(ptr1_at[i]-0x30); //低位
 285   3                                         i++;
 286   3                                         if(ptr1_at[i]!=','&&ptr1_at[i+1]==',') //可以存100以上的
 287   3                                         { j=j*10;i++;
 288   4                                           j=j+(ptr1_at[i]-0x30);
 289   4      
 290   4                                        }
 291   3                        //返回是可以存多少短信
 292   3                                        //r=j+10;
 293   3      
 294   3                                  }
 295   2      
 296   2                              }
 297   1                 else   //出错处理
 298   1                 {   if(ptr1_at[1]==0x0d&&ptr1_at[0]==0x34)
 299   2                              {
 300   3                                          return(0);
 301   3                          }
 302   2      
 303   2                 }
C51 COMPILER V7.50   CHESHI                                                                03/28/2011 00:32:41 PAGE 6   

 304   1      
 305   1               r=j;
 306   1        //---------下面有短信时,进行短信查找 从1-100------------------------------------
 307   1               num_tmp1=1;
 308   1              do{
 309   2                  if(r>=100)  //短信存储号不能超过100个
 310   2                      r=1; //
 311   2                  if(r==1)         //如果是一条发AT+CMGL=ALL或AT+CMGL=4
 312   2                      {
 313   3                         Send_AT_Command(SMS_CMGL,ptr1_at,0);
 314   3      
 315   3                                         if(i=strsearch("+CMGL:\x20",ptr1_at))  //查短信代码回复是否对
 316   3                                          {  i=i+6;
 317   4                                            if(ptr1_at[i+1]==',')
 318   4                                                {
 319   5                                                  num_tmp1=ptr1_at[i]-0x30; //当前短信存储号 10以内
 320   5                                                }
 321   4                                                else        //当前短信存储号 10以上
 322   4                                                {
 323   5                                                    num_tmp1=ptr1_at[i++]-0x30;
 324   5                                                    num_tmp1=num_tmp1*10;
 325   5                                                        num_tmp1=num_tmp1+ptr1_at[i++]-0x30;
 326   5      
 327   5                                                }
 328   4                                            sms_num_tmp=num_tmp1;
 329   4                                            return(1);
 330   4                                          }
 331   3      
 332   3      
 333   3                      }
 334   2                              else
 335   2                                      {
 336   3                              i= READ_TEL(ptr1_at,num_tmp1) ;
 337   3                              if(i) //有短信跳出
 338   3                                        {    i=i+7;
 339   4                                             sms_num_tmp=num_tmp1;
 340   4                                             return(1);
 341   4                                        }
 342   3      
 343   3                                      }
 344   2      
 345   2                              r--;
 346   2                              num_tmp1++; //
 347   2             }while(r!=0);
 348   1            //---------------------------------------------
 349   1             return(0);
 350   1      
 351   1      
 352   1      }
 353          
 354          
 355          /*
 356          *********************************************************************************************************
 357          ** 函数名称      read_sms()
 358          ** 函数功能               进行SIM卡的电话本读
 359          ** 全局变量或数组:   receive_count 接收指针
 360          ** 入口参数      ：  AT指令 字符串str_code -para_temp   str_at- uart_buff
 361                                  *str_at=要复制的内容/转AT指令
 362                              str_code 短信内容
 363                                  *ptr_tel   电话号码
 364          
 365          ** 出口参数     ： 1-成功      0-失败
C51 COMPILER V7.50   CHESHI                                                                03/28/2011 00:32:41 PAGE 7   

 366          *********************************************************************************************************
 367          */
 368          
 369          //====================================================
 370          uchar  read_sms(char* ptr1_at,char* ptr1_code,char* ptr_tel)
 371          {
 372   1      
 373   1               uint  i;
 374   1           uchar idata  j,  PDU_TEXT,y;
 375   1           if(!CPMS_SM(ptr1_at))
 376   1           {
 377   2                      return(0);
 378   2           }
 379   1      
 380   1            if((i=strsearch("08916831",ptr1_at)))//短信中心号码字头  //如果不是,说明没有短信
 381   1                       {  i=i+17;  j=0;
 382   2                            //带+86的中国移动与联通手机
 383   2                          if((ptr1_at[i]>='0')&&(ptr1_at[i+1]>='0'))
 384   2                              {  i=i+2;  //当前指针移动两位
 385   3                                   //_______取出对方号码长度______________
 386   3                                   j=ptr1_at[i++]-0x30;  //取高位
 387   3                                   j=j*16;   //称入高位
 388   3                                   if(ptr1_at[i]>=0x41)    //大于9的低位处理
 389   3                                       {
 390   4                                               j=j+(ptr1_at[i++]-0x37);
 391   4                                       }
 392   3                                       else    //9及以下处理
 393   3                                         j=j+(ptr1_at[i++]-0x30);
 394   3                                   //___________________________
 395   3                                    //-接入码-- 9186  与A1 接入码字头
 396   3                                        if(ptr1_at[i]=='9') //
 397   3                                        {
 398   4                                              i=i+4;  //指针移动4位,去掉 9186
 399   4                                        }
 400   3                                    else
 401   3                                      i=i+2;  // 指针移动2位,去掉 A1
 402   3                                        //j=j-1;
 403   3                                       //------------对方号码查找---------------
 404   3                                       //--电话号码存入 TEL_temp数组
 405   3                                         y=0;
 406   3                                    do {
 407   4                                         j--;j--;
 408   4                             ptr_tel[y++]=ptr1_at[i+1];
 409   4                             if(ptr1_at[i]=='F') //有补码
 410   4                             {  ptr_tel[y]=0;
 411   5                                i++; i++;
 412   5                                                    break;
 413   5                             }
 414   4                             ptr_tel[y++]=ptr1_at[i];
 415   4                             i=i+2;
 416   4                               if(y>15) break; //长度不能超过20
 417   4                                      }while(j!=0);
 418   3                                              ptr_tel[y]=0;
 419   3                                       //---------------------------------
 420   3                            //i=i+1;
 421   3                            //是否是中文模式 0008   2100
 422   3                                              if((ptr1_at[i]>='0')&&(ptr1_at[i+1]>='0')&&(ptr1_at[i+2]>='0')
 423   3                                              &&(ptr1_at[i+3]=='8'))
 424   3                                              {
 425   4                                                i=i+4; //移动4位,去掉本0008
 426   4                            i=i+14; //移动14位,去掉本日期及时间
 427   4                                                i=i+2;
C51 COMPILER V7.50   CHESHI                                                                03/28/2011 00:32:41 PAGE 8   

 428   4                             //----------内容复制-将内容放到para_temp里------
 429   4                             for(j=0;j<=MAX_T-3;j++)  //不能超过最大值
 430   4                             {
 431   5                                   ptr1_code[j]=ptr1_at[i++];
 432   5                                                        if(ptr1_at[i]==0x0d)
 433   5                                                        {  ptr1_code[++j]=0; break;
 434   6                                                        }
 435   5                                PDU_TEXT=0;   //PDU
 436   5                                if(i>=MAX_TM)  break;
 437   5                             }
 438   4                            //---------------------
 439   4                                              }
 440   3                                      // 英文模式
 441   3                                    //+CMGR: "REC READ","8613818120592",,"09/06/25,14:16:33+32",145,4,0,0,"8613800210500",
 442   3                                              //145,3
 443   3                                              //END  0
 444   3                                   //  2B 43 4D 47 52 3A 20 22 52 45 43 20 52 45 41 44 22 2C 22 38 36 31 33 38 31 38 31 32 30 35 39 3
             -2 22
 445   3                                   //2C 2C 22 30 39 2F 30 36 2F 32 35 2C 31 34 3A 31 36 3A 33 33 2B 33 32 22 2C 31 34 35 2C 34 2C 30 
             -2C 30
 446   3                                   // 2C 22 38 36 31 33 38 30 30 32 31 30 35 30 30 22 2C
 447   3                                       //31 34 35 2C 33 0D 0A 45 4E 44 0D 0A 30 0D
 448   3      
 449   3                                       else
 450   3                                      {        PDU_TEXT=1;//文本
 451   4                                                   goto err_dll;
 452   4      
 453   4      
 454   4                                    }
 455   3                                      //i++;
 456   3      
 457   3                           } //固定代码对不对
 458   2                   else goto err_dll;
 459   2      
 460   2      
 461   2      
 462   2                       } //08916831
 463   1               else
 464   1                  goto err_dll;
 465   1      
 466   1      
 467   1          if(PDU_TEXT==0) //中文内容分析
 468   1          {     i=0;
 469   2                //5438 5408  吸合
 470   2              if(strsearch1(i,"54385408",ptr1_code))
 471   2                               {
 472   3      
 473   3      
 474   3                                      IO_OUT=0;
 475   3                                      strcpy(ptr1_code,"SET OK\x1a");
 476   3      
 477   3                                      return(1);
 478   3      
 479   3                               }
 480   2              //  断开 65AD 5F00   PUD码
 481   2             else  if(strsearch1(i,"65AD5F0",ptr1_code))
 482   2                               {
 483   3      
 484   3      
 485   3                                        IO_OUT=1;
 486   3                                        return(2);
 487   3      
C51 COMPILER V7.50   CHESHI                                                                03/28/2011 00:32:41 PAGE 9   

 488   3                               }
 489   2                  else goto err_dll;
 490   2      
 491   2      
 492   2      
 493   2      }
 494   1        //------------------------------------------------------------
 495   1         else   if(PDU_TEXT==1)//英文
 496   1           {
 497   2      
 498   2                         goto err_dll;
 499   2      
 500   2      
 501   2                      }
 502   1              //-------------------------------------------------------------------
 503   1      
 504   1                              else {
 505   2      
 506   2      err_dll:                        //短信号码删除 AT+CMGD=01
 507   2                                              CMGD_GSM(ptr1_at,  sms_num_tmp );
 508   2      
 509   2                                              for(i=1;i<=MAX_TM-3;i++)
 510   2                                      {    ptr1_at[i]=0; }
 511   2      
 512   2                                Send_AT_Command(AT_CMGF0,ptr1_at,0);  //中文方式
 513   2                                        Send_AT_Command(AT_CNMI,ptr1_at,0);//AT+CNMI=2,1
 514   2                                              // return;
 515   2      
 516   2                                       }
 517   1      
 518   1      
 519   1      
 520   1                   return(0);
 521   1      
 522   1      
 523   1      
 524   1      
 525   1      
 526   1      }
 527          
 528          /*
 529          *********************************************************************************************************
 530          ** 函数名称      READ_TEL()
 531          ** 函数功能                进行SIM卡中的1到20条短信号码的读取
 532          ** 全局变量或数组:   receive_count 接收指针
 533          ** 入口参数      ：  AT指令 字符串
 534                                                  str_at- uart_buff   str_code -para_temp
 535          **                      *str_at=要复制的内容/转AT指令
 536          **                      *str_code  短信内容
 537                               id 短信号
 538          ** 出口参数     ： 1-成功      0-失败
 539          *********************************************************************************************************
 540          */
 541          //======================================================================
 542          //======================================================================
 543          //======================================================================
 544          uchar   READ_TEL(char* ptr1_at,uchar  id)                //读短信号码１－２０个
 545          {
 546   1      
 547   1                  uchar idata ptr1[5],t;
 548   1              t=0;
 549   1              ptr1[t++]=(id/10)+0x30;
C51 COMPILER V7.50   CHESHI                                                                03/28/2011 00:32:41 PAGE 10  

 550   1              ptr1[t++]=(id%10)+0x30;
 551   1              ptr1[t++]=0;ptr1[t++]=0x00;
 552   1               Send_AT_Command(SMS_CMGR,ptr1_at,ptr1);
 553   1           timercount=0; while(timercount<20) ;
 554   1      
 555   1          // if(t=strsearch("+CMGR: 0,,0",ptr1_at))
 556   1               if(receive_count<10)
 557   1               {return(0);
 558   2                }
 559   1            return(1);
 560   1      
 561   1      }
 562          
 563          
 564            /*
 565          *********************************************************************************************************
 566          ** 函数名称 Initialize_Model()
 567          ** 函数功能 ： 模块初始化
 568          ** 入口参数 ：ptr1_at --uart_buff AT指令发送用 ptr1_code -para_temp 参数内容
 569          **             全局 变最    ptr1_at, uart_buff, receive_count
 570          ** 出口参数 :
 571          *********************************************************************************************************
 572          */
 573          
 574          void Initialize_Model(char* ptr1_at,char* ptr1_code)    //初始化　PIN检测
 575          {
 576   1              uchar i,j;
 577   1           GPS_ON=1;
 578   1               BELL=0;  for(i=0;i<=100;i++) dmsec(1);  BELL=1;
 579   1         //  GPS_READ(ptr1_at,ptr1_code);
 580   1      
 581   1           ptr1_code[0]=0;
 582   1              for(i=0;i<15;i++)
 583   1              {   //进行初始化,并显示  ATE0V0  = ATE0 ATV0   AT_E
 584   2                      Send_AT_Command(AT_E,ptr1_at,0);
 585   2                      Send_AT_Command(AT_INIT,ptr1_at,0);
 586   2                      if(ptr1_at[1]==0x0d&&ptr1_at[0]==0x30)
 587   2                      {  break;}
 588   2              else if(ptr1_at[receive_count-1]==0x0d&&ptr1_at[receive_count-2]=='0')
 589   2               {  break;}
 590   2      
 591   2                      if(i==1)
 592   2                      {   IO_IGT=0;   for(i=0;i<=200;i++) dmsec(30);IO_IGT=1;
 593   3                          timercount=0; while(timercount<60);
 594   3                      }
 595   2      
 596   2      
 597   2                 timercount=0; while(timercount<60);
 598   2      
 599   2          }
 600   1      
 601   1              for(i=0;i<12;i++)
 602   1              {            //读卡  AT+CPIN?
 603   2      
 604   2                        Send_AT_Command(AT_E,ptr1_at,0);
 605   2                               Send_AT_Command(AT_INIT,ptr1_at,0);
 606   2                       Send_AT_Command(AT_CPIN,ptr1_at,0) ;
 607   2                       //如有收到回应进行分析收到的信息,
 608   2                       timercount=0; while(timercount<2);
 609   2                              if(j=strsearch("READY",ptr1_at))
 610   2                                      break;
 611   2      
C51 COMPILER V7.50   CHESHI                                                                03/28/2011 00:32:41 PAGE 11  

 612   2                  timercount=0; while(timercount<60);
 613   2              }
 614   1      
 615   1      
 616   1      
 617   1      
 618   1              Send_AT_Command(AT_IPR,ptr1_at,0);//波特率  AT+IPR=9600
 619   1              Send_AT_Command(AT_CGMM,ptr1_at,0);  //模块型号 AT+CGMM
 620   1      
 621   1      
 622   1           timer_S_cnt=0; while(timer_S_cnt<10) ;
 623   1           BELL=0;  for(i=0;i<=100;i++) dmsec(1);  BELL=1;
 624   1           Send_AT_Command(AT_CNMI,ptr1_at,0);
 625   1           Send_AT_Command(AT_CMGF0,ptr1_at,0);//AT+CMGF=0
 626   1      }
 627          
 628          
 629            /*
 630          *********************************************************************************************************
 631          ** 函数名称 Sys_Init()
 632          ** 函数功能 ： 单片机初始化
 633          ** 入口参数 ：
 634          **             全局 变最  timer_1S_cnt  receive_count
 635          ** 出口参数 :
 636          *********************************************************************************************************
 637          */
 638          
 639          void  Sys_Init(void)//话机启动的初始化程序,包含键盘与定时器,串口等
 640          {
 641   1                              //TH0=(65536-46080)/256;//重新装入定时25mS的初值到TH0,TL0     56320
 642   1                              //TL0=(65536-46080)%256;
 643   1                              //65536-(11.0592/12)*20MS*1000=To    18432     47104
 644   1                              //1ms定时
 645   1                              //11.0592/12 = 0.9216 M (记数频率)
 646   1                              //1ms记数 921.6次
 647   1                              //16位 2^16 - x = 922 x=64614 FC66
 648   1                              //定时器里不断放fc66，不用怀疑51定时器得到的 1ms的精确性吗
 649   1      
 650   1              TH0 = 0xB8;
 651   1              TL0 = 0x00; //20ms的时钟基准
 652   1      
 653   1        //串口中断
 654   1          TI=0; RI=0;
 655   1          SCON=0x50;                  //选用方式1
 656   1          TMOD=0x20;
 657   1          TMOD = (TMOD & 0xf0) | 1;//MODE 1
 658   1         // TH1=0xe8;              //波特率为9600
 659   1         // TL1=0xe8;
 660   1         TH1=0xfd;              //波特率为9600
 661   1         TL1=0xfd;
 662   1          PCON=0x00;            //倍频0x80
 663   1          IE = 0xb0;          // EA XX ET2 ES ET0 EX0 ET1 EX1
 664   1          TR1=1;              //enable TIMER1
 665   1      
 666   1          ES=1;  //开串口开断
 667   1          TR0=1; //串口接收中断
 668   1          ET0=1;  //T0 中断
 669   1          ET1=0;  // T1 中断
 670   1          EA=1;
 671   1          P0=0xFF;
 672   1          P1=0xFF;
 673   1          P2=0xFF;
C51 COMPILER V7.50   CHESHI                                                                03/28/2011 00:32:41 PAGE 12  

 674   1          P3=0xFF;
 675   1         // P4=0xff;
 676   1          timer_1S_cnt=0;receive_count=0;
 677   1          IO_IGT=1;
 678   1      
 679   1      
 680   1      
 681   1      }
 682           //======================================================
 683          //这里为AT指令处理区,所有的AT指令都在这时对uart_buff数组进行赋值,并发送出去,
 684          //-正常情况下,AT指令反回也会在这里接收完
 685            //------------------------
 686            //-----------------------
 687            ///==========================================
 688          /*
 689          *********************************************************************************************************
 690          ** 函数名称      ：Send_AT_Command()
 691          ** 函数功能              ：串口AT指令发送前处理,
 692          ** 全局变量或数组:   receive_count 接收指针
 693          ** 入口参数      ： type =ID,  转向所有  AT指令 字符串
 694                                                  str_at- uart_buff   str_code -para_temp
 695          **                      *str_at=要复制的内容/转AT指令
 696          **                      *str_code 与*str_at合并的参数 //AT指令参数
 697          ** 出口参数     ：  1- 成功,  0- 失败
 698          *********************************************************************************************************
 699          */
 700          uchar  Send_AT_Command( uchar type,uchar *str_at ,uchar *str_code)      //发送ＡＴ指令
 701          //拨号时号码放在phone.number
 702          //其他用para_temp
 703          {
 704   1              uint   i;
 705   1               GPS_ON=1;
 706   1          switch(type)
 707   1          {
 708   2      
 709   2      
 710   2      
 711   2            case AT_CPIN:             //检查当前是否要输入PIN码
 712   2              strcpy(str_at,"AT+CPIN?");
 713   2              break;
 714   2           //  AT_E
 715   2             case AT_E:               //ATE0 功能关回显  ATE1 开回显
 716   2              strcpy(str_at,"ATE0");
 717   2              break;
 718   2            case AT_INIT:             //ATV0  回复方式 30 0D  ATV1 回复方式  OK
 719   2              strcpy(str_at,"ATV0");
 720   2              break;
 721   2              //0D 0A 54 43 33 35 0D 0A
 722   2            case   AT_CGMM:   //模块版型号
 723   2              strcpy(str_at,"AT+CGMM");
 724   2              break;
 725   2      
 726   2      
 727   2      
 728   2            case AT_CMGF0:    //PDU方式
 729   2                strcpy(str_at,"AT+CMGF=0");
 730   2              break;
 731   2          // AT_CNMI
 732   2            case AT_CNMI:    //   AT+CNMI=2,1
 733   2                strcpy(str_at,"AT+CNMI=2,1");
 734   2              break;
 735   2             case  AT_IPR:   // 波特率 9600
C51 COMPILER V7.50   CHESHI                                                                03/28/2011 00:32:41 PAGE 13  

 736   2              strcpy(str_at,"AT+IPR=9600"); break;
 737   2      
 738   2              case SMS_CMGL:          //删除一个短信
 739   2              // strcpy(uart_buff,"AT+CMGL=\"ALL\"");
 740   2              strcpy(str_at,"AT+CMGL=4");
 741   2            //  strcat(uart_buff,ptr);
 742   2              break;
 743   2      
 744   2            case SMS_CMGR:            //读一个短信
 745   2              strcpy(str_at,"AT+CMGR=");
 746   2              strcat(str_at,str_code);
 747   2              break;
 748   2      
 749   2             case SMS_CMGD:           //删除一个短信
 750   2              strcpy(str_at,"AT+CMGD=");
 751   2              strcat(str_at,str_code);
 752   2              break;
 753   2      
 754   2             case AT_CPMS:       //读短信报文
 755   2               strcpy(str_at,"AT+CPMS=\x22SM\x22");
 756   2              break;  //AT_CPMS
 757   2      
 758   2           //----------------------------------------------------
 759   2      
 760   2               //----------------------------------------------------------
 761   2      
 762   2           //-----------------------------------------------
 763   2            case AT_COMMAND:
 764   2              break;
 765   2            default:
 766   2              receive_count=0;
 767   2              return(TRUE);
 768   2          }
 769   1          ES=1;
 770   1          strcat(str_at,"\x0d\x00");//在命令后加入CR
 771   1          RI=0;                                       //清除接收标志
 772   1          TI=0;
 773   1         //------------------------------
 774   1          for(i=0;i<MAX_TM;i++)
 775   1              {       if(str_at[i]==0) break;
 776   2                      SBUF=str_at[i];
 777   2                      while(!TI);
 778   2                      TI=0;
 779   2              }
 780   1         //---------------------
 781   1         receive_count=0;
 782   1         str_at[0]=0; str_at[1]=0;str_at[2]=0;
 783   1         i=0; timer_1S_cnt=0;
 784   1         do{
 785   2             dmsec(3);
 786   2             if(receive_count>1)
 787   2             {   //   dmsec(50);
 788   3                  timercount=0; while(timercount<30);
 789   3                  break;
 790   3             }
 791   2      
 792   2          }while(timer_1S_cnt<3);
 793   1      
 794   1      
 795   1      
 796   1          return(TRUE);
 797   1      
C51 COMPILER V7.50   CHESHI                                                                03/28/2011 00:32:41 PAGE 14  

 798   1      
 799   1      
 800   1      }
 801          
 802          
 803          /******************************************/
 804          void main(void)
 805          {
 806   1              uchar i;
 807   1               Sys_Init();
 808   1      
 809   1              Initialize_Model(uart_buff,para_temp);//进行初始化
 810   1              P0=1;
 811   1      
 812   1              receive_count=0;
 813   1              sms_tmp=0;
 814   1      
 815   1      
 816   1      
 817   1              while(1)
 818   1              {
 819   2                      //-----------查询1到20条中的短信,只要有短信就处理------------------------------------------
 820   2      
 821   2      
 822   2                                      i=read_sms(uart_buff,para_temp,TEL_temp);                       //timer_S_cnt=0;
 823   2                                      if(i==0)
 824   2                                      {
 825   3                                          receive_count=0;
 826   3                                      timer_S_cnt=0; while(timer_S_cnt<60)
 827   3                                      {
 828   4                                                 if(strsearch( "+CMTI:",uart_buff))
 829   4                                                   { break; }
 830   4                                                 if(receive_count>=7)
 831   4                                                    {break; }
 832   4      
 833   4                                      }
 834   3      
 835   3      
 836   3                                      }
 837   2                     else
 838   2                     {
 839   3                         //加入回复短信程序
 840   3      
 841   3                              CMGD_GSM(uart_buff,sms_num_tmp );
 842   3                     }
 843   2      
 844   2      
 845   2      
 846   2      
 847   2      
 848   2              }
 849   1      
 850   1      
 851   1      }
 852          
 853          
 854          
 855          
 856          
 857          
 858          
 859          
C51 COMPILER V7.50   CHESHI                                                                03/28/2011 00:32:41 PAGE 15  

 860          
 861          
 862          
 863          
 864          
 865          
 866          
 867          
 868          
 869          
 870          
 871          
 872          
 873          
 874          
 875          
 876          
 877          
 878          
 879          
 880          
 881          
 882          
 883          
 884          
 885          
 886          
 887          
 888          
 889          
 890          
 891          
 892          
 893          
 894          
 895          
 896          
 897          
 898          
 899          
 900          
 901          
 902          
 903          
 904          
 905          
 906          
 907          
 908          
 909          
 910          
 911          
 912          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3149    ----
   CONSTANT SIZE    =    171    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     45      54
   IDATA SIZE       =    116       9
C51 COMPILER V7.50   CHESHI                                                                03/28/2011 00:32:41 PAGE 16  

   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
