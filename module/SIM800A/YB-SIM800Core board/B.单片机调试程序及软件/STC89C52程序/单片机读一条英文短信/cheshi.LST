C51 COMPILER V7.50   CHESHI                                                                04/28/2011 20:11:58 PAGE 1   


C51 COMPILER V7.50, COMPILATION OF MODULE CHESHI
OBJECT MODULE PLACED IN cheshi.OBJ
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE cheshi.C BROWSE DEBUG OBJECTEXTEND

line level    source

   1          //==**********************************************************
   2          //--软件功能, 读一条英文短信，但不回复，  START  END  两条，可以控制继电器
   3          //---   可使用单片机  要求 16K ROM 256 RAM 及以上 8位标准单片机   STC SST SM W78E单片机
   4          //--   TC35 SIM300 GTM900 EM310   波特率 9600
   5          //100%不支持  AT89S51 W78E51及其它RAM为 128B的单片机
   6          //============================================================
   7          #include <reg52.h>
   8          #include <cheshi.h>
   9          uchar data int_case;    //中断标志
  10          #define MAX_TM   100         // AT指收发数组最大缓冲
  11          #define MAX_T  35
  12          uchar idata uart_buff[MAX_TM]; //通信程序中的缓冲
  13          uchar idata  receive_count;    //发送与接收 数组指针
  14          
  15          uchar data para_temp[MAX_T];     //多用临时用
  16          uchar data read_tmp;             ///读电话本号参数
  17          uchar data sms_num_tmp;                 ///读短信号码参数
  18          uchar data sms_tmp;                     ///短信处理参数代码
  19          uchar idata TEL_temp[15];   //存对方号码，
  20          #define IO_OUT                  P3_6
  21          
  22          
  23          //－－－定时用－－－－－－－－－－－
  24          uint  data timercount;          //50MS定时器,
  25          uchar data timer_1S_cnt;
  26          uchar data timer_10S_cnt;
  27          uchar data timer_S_cnt;
  28          //--------------------
  29          uchar data ring_cnt;    //振铃用
  30           bit ring_bit  ;  // 电话呼入　2
  31          
  32          
  33          
  34          
  35          
  36            /*
  37          *********************************************************************************************************
  38          ** 函数名称 dmsec()
  39          ** 函数功能 ：延时 NS
  40          ** 入口参数 ：
  41          ** 出口参数 :
  42          *********************************************************************************************************
  43          */
  44          //---延时S------------------------------
  45          void dmsec (unsigned int count)
  46          {
  47   1              unsigned int i;
  48   1              while (count)
  49   1              {
  50   2      //              #if   CPU_TYPE2==W78E58
  51   2             //    i =115;
  52   2              //#elif  CPU_TYPE2==STC89E58
  53   2                 i =300;
  54   2              //#endif
  55   2      
C51 COMPILER V7.50   CHESHI                                                                04/28/2011 20:11:58 PAGE 2   

  56   2                      while (i>0) i--;
  57   2                      count--;
  58   2          }
  59   1      }
  60          
  61          
  62          //------------------------
  63          //----------------------
  64          /*
  65          *********************************************************************************************************
  66          ** 函数名称     Int_Timer0()
  67          ** 函数功能             定时器中断位,是整个程序的心跳,如果停止,程序会死机
  68          ** 全局变量或数组:
  69          
  70          ** 入口参数      ：
  71          ** 出口参数     ：
  72          *********************************************************************************************************
  73          */
  74          
  75          void  Int_Timer0(void) interrupt 1 using 3
  76          {
  77   1           TH0 = 0xB8;
  78   1               TL0 = 0x00; //20ms的时钟基准
  79   1      
  80   1         timer_1S_cnt++;   timercount++;
  81   1         if(timer_1S_cnt==50)    //20×50=1000MS  =1S
  82   1          { timer_10S_cnt++; timer_1S_cnt=0;
  83   2            timer_S_cnt++;
  84   2                LED_S0=~LED_S0;
  85   2      
  86   2          }                              //１秒＝１０００毫秒
  87   1          if(timer_10S_cnt==60)   //60S
  88   1          {
  89   2                 timer_10S_cnt=0;
  90   2      
  91   2              }
  92   1      
  93   1      //---------------------------------------------------------------------------------
  94   1      
  95   1      }
  96          
  97          /*
  98          *********************************************************************************************************
  99          ** 函数名称     Int_Uart()
 100          ** 函数功能              TC35 的命令列表,与中断服务程序
 101          ** 全局变量或数组:   receive_count 接收指针      uart_buff
 102                                ring_bit  ring_cnt
 103          ** 入口参数      ：
 104          ** 出口参数     ： 1-成功      0-失败
 105          *********************************************************************************************************
 106          */
 107          
 108          void  Int_Uart(void) interrupt 4 using 3  //串口的中断程序
 109          {
 110   1      
 111   1              if(RI) //命令方式
 112   1          {
 113   2      
 114   2                      RI=0;
 115   2      
 116   2               if((receive_count<MAX_TM-1))//没有发送时才能进行接收
 117   2                      {       //所有的命令返回都是处于 0x0A [Result] 0x0D 之间,其他命令,不会出现这种情况
C51 COMPILER V7.50   CHESHI                                                                04/28/2011 20:11:58 PAGE 3   

 118   3                      uart_buff[receive_count++]=SBUF;
 119   3                     //0D 0A 32 0D 0A
 120   3                      if((receive_count==5)&&(uart_buff[0]==0x0d&&uart_buff[1]==0x0A))
 121   3                      {
 122   4                         if(uart_buff[2]=='2')    //电话呼入
 123   4                                 {    ring_bit=1;  ring_cnt++;
 124   5                                     receive_count=0;
 125   5                                 }
 126   4                      }
 127   3                      }
 128   2                       else
 129   2                       {
 130   3                               return;
 131   3                       }
 132   2      
 133   2      
 134   2            //------------------------------------
 135   2      
 136   2              }//End of if(RI)
 137   1      }
 138          
 139          /*********************************************************************
 140           *                  C51中字符串函数的扩充                            *
 141           ** 函数名称    : strsearch ()
 142           ** 函数功能    : 在指定的数组里连续找到相同的内容
 143           ** 入口参数   ： ptr2=要找的内容, ptr1 当前数组
 144           **** 出口参数 ： 0-没有 找到   >1 查找到
 145           *********************************************************************/
 146          
 147          
 148          uchar strsearch(uchar *ptr2,uchar *ptr1_at)//查字符串*ptr2在*ptr1中的位置
 149          //本函数是用来检查字符串*ptr2是否完全包含在*ptr1中
 150          //返回:  0  没有找到
 151          //       1-255 从第N个字符开始相同
 152          {
 153   1      //、    uchar max_length;
 154   1              uchar i,j,k;
 155   1              uchar flag;
 156   1              if(ptr2[0]==0) return(0);
 157   1              flag=0;
 158   1              for(i=0,j=0;i<MAX_TM-2;i++)
 159   1              {
 160   2              if(ptr1_at[i]==ptr2[j])
 161   2              {//第一个字符相同
 162   3                      k=i;
 163   3                      //for(k=i;k<MAX_TM-2;k++,j++)
 164   3                      do {
 165   4                              if(ptr2[j]==0)//比较正确
 166   4                                      return(i+1);               //返回值是整数，不含0
 167   4                              if(ptr1_at[k]!=ptr2[j]) break;
 168   4                              k++;j++ ;
 169   4                      } while(k<MAX_TM-2) ;
 170   3      
 171   3                      j=0;
 172   3              }
 173   2              }
 174   1              return(0);
 175   1      }
 176          
 177          /*********************************************************************
 178           *                  C51中字符串函数的扩充                            *
 179           ** 函数名称    : strsearch1()
C51 COMPILER V7.50   CHESHI                                                                04/28/2011 20:11:58 PAGE 4   

 180           ** 函数功能    : 在指定的数组里连续找到相同的内容
 181           ** 入口参数   ： ptr2=要找的内容, ptr1 当前数组, id 数组开始的第一个位置
 182           **** 出口参数 ： 0-没有 找到   >1 查找到
 183           *********************************************************************/
 184          //------在指定移态的数组里连续找到相同的内容---------------------------------------
 185          //i=传来的指令,  *ptr2=要找的内容, uchar *ptr1 当前数组
 186          uchar strsearch1(uchar i,uchar *ptr2,uchar *ptr1)
 187          {      uchar j=0,k;
 188   1                              k=i;
 189   1            do{
 190   2                      if(ptr1[k]==ptr2[j])
 191   2                      {j++;k++;}
 192   2                      else return(0);
 193   2                      if(ptr2[j]==0)  return(k);
 194   2              }while(j<=60);
 195   1              return(0xff);
 196   1      }
 197          
 198          
 199          
 200          /*
 201          *********************************************************************************************************
 202          ** 函数名称      CMGD_GSM()
 203          ** 函数功能               删除短信   uart_buff
 204          ** 全局变量或数组:   uart_buff   sms_num_tmp
 205          ** 入口参数      ：  AT指令 字符串
 206                                  *str_at=要复制的内容/转AT指令
 207                              id    短信ID  供删除短信时用
 208          ** 出口参数     ：
 209          *********************************************************************************************************
 210          */
 211          //----------------------------------
 212          //删除短信   uart_buff
 213          void CMGD_GSM(char* ptr1_at,uchar id)
 214          {
 215   1               uchar  ptr1[3] ;
 216   1              ptr1[0]=(id/10)+0x30;
 217   1              ptr1[1]=(id%10)+0x30;
 218   1              ptr1[2]=0;
 219   1                Send_AT_Command(SMS_CMGD,ptr1_at,ptr1);    //删除其它没有用的短信
 220   1                Send_AT_Command(SMS_CMGD,ptr1_at,ptr1);
 221   1      
 222   1      
 223   1      }
 224          
 225          /*
 226          *********************************************************************************************************
 227          ** 函数名称      CPMS_SM()
 228          ** 函数功能               功能 读短信报文 ,有短信就读短信 ,把有短信的ID找到,并读出内容
 229          ** 全局变量或数组:   receive_count 接收指针  uart_buff  sms_num_tmp
 230          ** 入口参数      ：  AT指令 字符串
 231                                  *str_at=要复制的内容/转AT指令
 232                              sms_num_tmp     短信ID  供删除短信时用
 233          
 234          ** 出口参数     ： 1-成功      0-失败
 235          *********************************************************************************************************
 236          */
 237          
 238          uchar CPMS_SM(char* ptr1_at )
 239          //----------------------
 240          {   uchar i,j,r,num_tmp1;
 241   1            Send_AT_Command(AT_INIT,ptr1_at,0);
C51 COMPILER V7.50   CHESHI                                                                04/28/2011 20:11:58 PAGE 5   

 242   1            Send_AT_Command(AT_E,ptr1_at,0);
 243   1            Send_AT_Command(AT_CPMS,ptr1_at,0);
 244   1            if(i=strsearch("+CPMS:",ptr1_at)) //"SM"  +CPMS: 0,20,0,45,0,45
 245   1                               { i=i+5;
 246   2                                   //+CPMS: 0,20,0,45,0,45
 247   2                                if(strsearch1(i,"\x20\x30,",ptr1_at))  //没有短信
 248   2                               {     return(0);
 249   3                               }
 250   2                                else  if((ptr1_at[i]==' ')&&((ptr1_at[i+1]>'1')  //9以下短信处理
 251   2                                          &&(ptr1_at[i+1]<='9'))&&(ptr1_at[i+2]==','))
 252   2                             {      //+CPMS: 1,20,1,20,1,20
 253   3                                 i=i+1;
 254   3                                         r=ptr1_at[i]-0x30;   //有几个短个
 255   3                                         i++;//,
 256   3                                         i++; //20
 257   3                                         j=0;
 258   3                                         j=ptr1_at[i]-0x30;
 259   3                                         j=j*10; //高位
 260   3                                         i++;
 261   3                                         j=j+(ptr1_at[i]-0x30); //低位
 262   3                                         i++;
 263   3                                         if(ptr1_at[i]!=','&&ptr1_at[i+1]==',') //可以存100以上的
 264   3                                         { j=j*10;i++;
 265   4                                           j=j+(ptr1_at[i]-0x30);
 266   4      
 267   4                                        }
 268   3                       //返回是可以存多少短信
 269   3                                        //r=j+10;
 270   3                               }
 271   2                                else if((ptr1_at[i]==' ')&&((ptr1_at[i+1]>'0')  //10条短信以上处理
 272   2                                          &&(ptr1_at[i+2]>='0'))&&(ptr1_at[i+3]==','))
 273   2                             {
 274   3                                 i=i+1;
 275   3                                         r=ptr1_at[i++]-0x30;
 276   3                                         r=r*10;   //移到十位
 277   3                                         r=r+ptr1_at[i++]-0x30;
 278   3      
 279   3                                         i++; //20
 280   3                                         j=0;
 281   3                                         j=ptr1_at[i]-0x30;
 282   3                                         j=j*10; //高位
 283   3                                         i++;
 284   3                                         j=j+(ptr1_at[i]-0x30); //低位
 285   3                                         i++;
 286   3                                         if(ptr1_at[i]!=','&&ptr1_at[i+1]==',') //可以存100以上的
 287   3                                         { j=j*10;i++;
 288   4                                           j=j+(ptr1_at[i]-0x30);
 289   4      
 290   4                                        }
 291   3                        //返回是可以存多少短信
 292   3                                        //r=j+10;
 293   3      
 294   3                                  }
 295   2      
 296   2                              }
 297   1                 else   //出错处理
 298   1                 {   if(ptr1_at[1]==0x0d&&ptr1_at[0]==0x34)
 299   2                              {
 300   3                                          return(0);
 301   3                          }
 302   2      
 303   2                 }
C51 COMPILER V7.50   CHESHI                                                                04/28/2011 20:11:58 PAGE 6   

 304   1      
 305   1               r=j;
 306   1        //---------下面有短信时,进行短信查找 从1-100------------------------------------
 307   1               num_tmp1=1;
 308   1              do{
 309   2                  if(r>=100)  //短信存储号不能超过100个
 310   2                      r=1; //
 311   2                  if(r==1)         //如果是一条发AT+CMGL=ALL或AT+CMGL=4
 312   2                      {
 313   3                         Send_AT_Command(SMS_CMGL,ptr1_at,0);
 314   3      
 315   3                                         if(i=strsearch("+CMGL:\x20",ptr1_at))  //查短信代码回复是否对
 316   3                                          {  i=i+6;
 317   4                                            if(ptr1_at[i+1]==',')
 318   4                                                {
 319   5                                                  num_tmp1=ptr1_at[i]-0x30; //当前短信存储号 10以内
 320   5                                                }
 321   4                                                else        //当前短信存储号 10以上
 322   4                                                {
 323   5                                                    num_tmp1=ptr1_at[i++]-0x30;
 324   5                                                    num_tmp1=num_tmp1*10;
 325   5                                                        num_tmp1=num_tmp1+ptr1_at[i++]-0x30;
 326   5      
 327   5                                                }
 328   4                                            sms_num_tmp=num_tmp1;
 329   4                                            return(1);
 330   4                                          }
 331   3      
 332   3      
 333   3                      }
 334   2                              else
 335   2                                      {
 336   3                              i= READ_TEL(ptr1_at,num_tmp1) ;
 337   3                              if(i) //有短信跳出
 338   3                                        {    i=i+7;
 339   4                                             sms_num_tmp=num_tmp1;
 340   4                                             return(1);
 341   4                                        }
 342   3      
 343   3                                      }
 344   2      
 345   2                              r--;
 346   2                              num_tmp1++; //
 347   2             }while(r!=0);
 348   1            //---------------------------------------------
 349   1             return(0);
 350   1      
 351   1      
 352   1      }
 353          
 354          
 355          /*
 356          *********************************************************************************************************
 357          ** 函数名称      read_sms()
 358          ** 函数功能               进行SIM卡的电话本读
 359          ** 全局变量或数组:   receive_count 接收指针
 360          ** 入口参数      ：  AT指令 字符串str_code -para_temp   str_at- uart_buff
 361                                  *str_at=要复制的内容/转AT指令
 362                              str_code 短信内容
 363                                  *ptr_tel   电话号码
 364          
 365          ** 出口参数     ： 1-成功      0-失败
C51 COMPILER V7.50   CHESHI                                                                04/28/2011 20:11:58 PAGE 7   

 366          *********************************************************************************************************
 367          */
 368          
 369          //====================================================
 370          uchar  read_sms(char* ptr1_at,char* ptr1_code,char* ptr_tel)
 371          {
 372   1      
 373   1               uint  i;
 374   1           uchar idata  j,  PDU_TEXT;
 375   1           if(!CPMS_SM(ptr1_at))
 376   1           {
 377   2                      return(0);
 378   2           }
 379   1      
 380   1      
 381   1      
 382   1                                      // 英文模式
 383   1                                    //+CMGR: "REC READ","8613818120592",,"09/06/25,14:16:33+32",145,4,0,0,"8613800210500",
 384   1                                              //145,3
 385   1                                              //END  0
 386   1                                   //  2B 43 4D 47 52 3A 20 22 52 45 43 20 52 45 41 44 22 2C 22 38 36 31 33 38 31 38 31 32 30 35 39 3
             -2 22
 387   1                                   //2C 2C 22 30 39 2F 30 36 2F 32 35 2C 31 34 3A 31 36 3A 33 33 2B 33 32 22 2C 31 34 35 2C 34 2C 30 
             -2C 30
 388   1                                   // 2C 22 38 36 31 33 38 30 30 32 31 30 35 30 30 22 2C
 389   1                                       //31 34 35 2C 33 0D 0A 45 4E 44 0D 0A 30 0D
 390   1                          //READ","
 391   1                           if((i=strsearch("READ\",\"",ptr1_at)))
 392   1                           {      i=i+6;
 393   2      
 394   2                                    for(j=0;j<20;j++)
 395   2                                                               {
 396   3                                                                      ptr_tel[j]=uart_buff[i++];
 397   3                                                                      if(uart_buff[i]==0x22)   break;
 398   3                                                              }
 399   2                                              ptr_tel[j+1]=0;     ptr_tel[j+2]=0x00;
 400   2      
 401   2                           }
 402   1                                          //AT_CMGF1
 403   1      
 404   1                               timercount=0; while(timercount<8)  ;
 405   1                               //从短信代码中找到维一代码与内容间的字符
 406   1                               if((i=strsearch("\x0d\x0a",ptr1_at)))
 407   1                                                      {     i=i+1;//指针移动两位,指向内容的第一个字符
 408   2                                                            //----内容复制-将内容放到para_temp里------------
 409   2                                                             for(j=0;j<=MAX_T-3;j++)
 410   2                                                 {
 411   3                                                        ptr1_code[j]=ptr1_at[i++];
 412   3                                                        //大小写转换
 413   3                                            toupper(ptr1_code[j]);
 414   3                                                                                      if(ptr1_at[i]==0x0d)
 415   3                                                                                      { ptr1_code[++j]=0; break;
 416   4                                                                                      }
 417   3                                                    if(i>=MAX_TM)  break;
 418   3                                                 }
 419   2                                       //---------------------
 420   2                                                      }
 421   1                                 else   goto err_dll;
 422   1                                           PDU_TEXT=1;//文本
 423   1      
 424   1      
 425   1      
C51 COMPILER V7.50   CHESHI                                                                04/28/2011 20:11:58 PAGE 8   

 426   1      
 427   1        //------------------------------------------------------------
 428   1              i=0;
 429   1                 if(strsearch1(i,"START",ptr1_code))
 430   1                 {
 431   2      
 432   2      
 433   2      //                              IO_OUT=0; //继电器吸合
 434   2                                  strcpy(ptr1_code,"OUT ON OK\x1a");
 435   2      
 436   2                                       return(1);
 437   2      
 438   2                      }
 439   1               else if(strsearch1(i,"END",ptr1_code))
 440   1                 {
 441   2      
 442   2      
 443   2      //                               IO_OUT=1;   // 继电器断开
 444   2      //                              strcpy(ptr1_code,"OUT OFF OK\x1a");
 445   2                                       return(1);
 446   2      
 447   2                      }
 448   1      
 449   1      
 450   1      
 451   1      
 452   1              //-------------------------------------------------------------------
 453   1      
 454   1                       else {
 455   2      
 456   2                      //短信号码删除 AT+CMGD=01
 457   2              err_dll:
 458   2                                              CMGD_GSM(ptr1_at,  sms_num_tmp );
 459   2      
 460   2                                              for(i=1;i<=MAX_TM-3;i++)
 461   2                                      {    ptr1_at[i]=0; }
 462   2      
 463   2                                  Send_AT_Command(AT_CMGF1,ptr1_at,0);  //中文方式
 464   2                                          Send_AT_Command(AT_CNMI,ptr1_at,0);//AT+CNMI=2,1
 465   2      
 466   2                                }
 467   1      
 468   1      
 469   1      
 470   1                   return(0);
 471   1      
 472   1      
 473   1      
 474   1      
 475   1      
 476   1      }
 477          
 478          /*
 479          *********************************************************************************************************
 480          ** 函数名称      READ_TEL()
 481          ** 函数功能                进行SIM卡中的1到20条短信号码的读取
 482          ** 全局变量或数组:   receive_count 接收指针
 483          ** 入口参数      ：  AT指令 字符串
 484                                                  str_at- uart_buff   str_code -para_temp
 485          **                      *str_at=要复制的内容/转AT指令
 486          **                      *str_code  短信内容
 487                               id 短信号
C51 COMPILER V7.50   CHESHI                                                                04/28/2011 20:11:58 PAGE 9   

 488          ** 出口参数     ： 1-成功      0-失败
 489          *********************************************************************************************************
 490          */
 491          //======================================================================
 492          //======================================================================
 493          //======================================================================
 494          uchar   READ_TEL(char* ptr1_at,uchar  id)                //读短信号码１－２０个
 495          {
 496   1      
 497   1                  uchar idata ptr1[5],t;
 498   1              t=0;
 499   1              ptr1[t++]=(id/10)+0x30;
 500   1              ptr1[t++]=(id%10)+0x30;
 501   1              ptr1[t++]=0;ptr1[t++]=0x00;
 502   1               Send_AT_Command(SMS_CMGR,ptr1_at,ptr1);
 503   1           timercount=0; while(timercount<20) ;
 504   1      
 505   1          // if(t=strsearch("+CMGR: 0,,0",ptr1_at))
 506   1               if(receive_count<10)
 507   1               {return(0);
 508   2                }
 509   1            return(1);
 510   1      
 511   1      }
 512          
 513          
 514            /*
 515          *********************************************************************************************************
 516          ** 函数名称 Initialize_Model()
 517          ** 函数功能 ： 模块初始化
 518          ** 入口参数 ：ptr1_at --uart_buff AT指令发送用 ptr1_code -para_temp 参数内容
 519          **             全局 变最    ptr1_at, uart_buff, receive_count
 520          ** 出口参数 :
 521          *********************************************************************************************************
 522          */
 523          
 524          void Initialize_Model(char* ptr1_at,char* ptr1_code)    //初始化　PIN检测
 525          {
 526   1              uchar i,j; 
 527   1      
 528   1           ptr1_code[0]=0;
 529   1              for(i=0;i<15;i++)
 530   1              {   //进行初始化,并显示  ATE0V0  = ATE0 ATV0   AT_E
 531   2                      Send_AT_Command(AT_E,ptr1_at,0);
 532   2                      Send_AT_Command(AT_INIT,ptr1_at,0);
 533   2                      if(ptr1_at[1]==0x0d&&ptr1_at[0]==0x30)
 534   2                      {  break;}
 535   2              else if(ptr1_at[receive_count-1]==0x0d&&ptr1_at[receive_count-2]=='0')
 536   2               {  break;}
 537   2      
 538   2                      if(i==1)
 539   2                      {  // IO_IGT=0;   for(i=0;i<=200;i++) dmsec(30);IO_IGT=1;
 540   3                          timercount=0; while(timercount<60);
 541   3                      }
 542   2      
 543   2      
 544   2                 timercount=0; while(timercount<60);
 545   2      
 546   2          }
 547   1      
 548   1              for(i=0;i<12;i++)
 549   1              {            //读卡  AT+CPIN?
C51 COMPILER V7.50   CHESHI                                                                04/28/2011 20:11:58 PAGE 10  

 550   2      
 551   2                        Send_AT_Command(AT_E,ptr1_at,0);
 552   2                               Send_AT_Command(AT_INIT,ptr1_at,0);
 553   2                       Send_AT_Command(AT_CPIN,ptr1_at,0) ;
 554   2                       //如有收到回应进行分析收到的信息,
 555   2                       timercount=0; while(timercount<2);
 556   2                              if(j=strsearch("READY",ptr1_at))
 557   2                                      break;
 558   2      
 559   2                  timercount=0; while(timercount<60);
 560   2              }
 561   1      
 562   1      
 563   1      
 564   1      
 565   1              Send_AT_Command(AT_IPR,ptr1_at,0);//波特率  AT+IPR=9600
 566   1              Send_AT_Command(AT_CGMM,ptr1_at,0);  //模块型号 AT+CGMM
 567   1      
 568   1      
 569   1           timer_S_cnt=0; while(timer_S_cnt<12) ;
 570   1      //     BELL=0;  for(i=0;i<=100;i++) dmsec(1);  BELL=1;
 571   1           Send_AT_Command(AT_CNMI,ptr1_at,0);
 572   1           Send_AT_Command(AT_CMGF1,ptr1_at,0);//AT+CMGF=1
 573   1      }
 574          
 575          
 576            /*
 577          *********************************************************************************************************
 578          ** 函数名称 Sys_Init()
 579          ** 函数功能 ： 单片机初始化
 580          ** 入口参数 ：
 581          **             全局 变最  timer_1S_cnt  receive_count
 582          ** 出口参数 :
 583          *********************************************************************************************************
 584          */
 585          
 586          void  Sys_Init(void)//话机启动的初始化程序,包含键盘与定时器,串口等
 587          {
 588   1                              //TH0=(65536-46080)/256;//重新装入定时25mS的初值到TH0,TL0     56320
 589   1                              //TL0=(65536-46080)%256;
 590   1                              //65536-(11.0592/12)*20MS*1000=To    18432     47104
 591   1                              //1ms定时
 592   1                              //11.0592/12 = 0.9216 M (记数频率)
 593   1                              //1ms记数 921.6次
 594   1                              //16位 2^16 - x = 922 x=64614 FC66
 595   1                              //定时器里不断放fc66，不用怀疑51定时器得到的 1ms的精确性吗
 596   1      
 597   1              TH0 = 0xB8;
 598   1              TL0 = 0x00; //20ms的时钟基准
 599   1      
 600   1        //串口中断
 601   1          TI=0; RI=0;
 602   1          SCON=0x50;                  //选用方式1
 603   1          TMOD=0x20;
 604   1          TMOD = (TMOD & 0xf0) | 1;//MODE 1
 605   1         // TH1=0xe8;              //波特率为9600
 606   1         // TL1=0xe8;
 607   1         TH1=0xfd;              //波特率为9600
 608   1         TL1=0xfd;
 609   1          PCON=0x00;            //倍频0x80
 610   1          IE = 0xb0;          // EA XX ET2 ES ET0 EX0 ET1 EX1
 611   1          TR1=1;              //enable TIMER1
C51 COMPILER V7.50   CHESHI                                                                04/28/2011 20:11:58 PAGE 11  

 612   1      
 613   1          ES=1;  //开串口开断
 614   1          TR0=1; //串口接收中断
 615   1          ET0=1;  //T0 中断
 616   1          ET1=0;  // T1 中断
 617   1          EA=1;
 618   1          P0=0xFF;
 619   1          P1=0xFF;
 620   1          P2=0xFF;
 621   1          P3=0xFF;
 622   1         // P4=0xff;
 623   1          timer_1S_cnt=0;receive_count=0;
 624   1      //    IO_IGT=1;
 625   1      
 626   1      
 627   1      
 628   1      }
 629           //======================================================
 630          //这里为AT指令处理区,所有的AT指令都在这时对uart_buff数组进行赋值,并发送出去,
 631          //-正常情况下,AT指令反回也会在这里接收完
 632            //------------------------
 633            //-----------------------
 634            ///==========================================
 635          /*
 636          *********************************************************************************************************
 637          ** 函数名称      ：Send_AT_Command()
 638          ** 函数功能              ：串口AT指令发送前处理,
 639          ** 全局变量或数组:   receive_count 接收指针
 640          ** 入口参数      ： type =ID,  转向所有  AT指令 字符串
 641                                                  str_at- uart_buff   str_code -para_temp
 642          **                      *str_at=要复制的内容/转AT指令
 643          **                      *str_code 与*str_at合并的参数 //AT指令参数
 644          ** 出口参数     ：  1- 成功,  0- 失败
 645          *********************************************************************************************************
 646          */
 647          uchar  Send_AT_Command( uchar type,uchar *str_at ,uchar *str_code)      //发送ＡＴ指令
 648          //拨号时号码放在phone.number
 649          //其他用para_temp
 650          {
 651   1              uint   i;
 652   1      //         GPS_ON=1;
 653   1          switch(type)
 654   1          {
 655   2      
 656   2            case AT_CPIN:             //检查当前是否要输入PIN码
 657   2              strcpy(str_at,"AT+CPIN?");
 658   2              break;
 659   2           //  AT_E
 660   2             case AT_E:               //ATE0 功能关回显  ATE1 开回显
 661   2              strcpy(str_at,"ATE0");
 662   2              break;
 663   2            case AT_INIT:             //ATV0  回复方式 30 0D  ATV1 回复方式  OK
 664   2              strcpy(str_at,"ATV0");
 665   2              break;
 666   2              //0D 0A 54 43 33 35 0D 0A
 667   2            case   AT_CGMM:   //模块版型号
 668   2              strcpy(str_at,"AT+CGMM");
 669   2              break;
 670   2      
 671   2           case AT_CMGF1:     //SMS 接收方式,
 672   2              strcpy(str_at,"AT+CMGF=1");
 673   2              break;
C51 COMPILER V7.50   CHESHI                                                                04/28/2011 20:11:58 PAGE 12  

 674   2          // AT_CNMI
 675   2            case AT_CNMI:    //   AT+CNMI=2,1
 676   2                strcpy(str_at,"AT+CNMI=2,1");
 677   2              break;
 678   2             case  AT_IPR:   // 波特率 9600
 679   2              strcpy(str_at,"AT+IPR=9600"); break;
 680   2      
 681   2              case SMS_CMGL:          //读所有短信
 682   2               strcpy(uart_buff,"AT+CMGL=\"ALL\"");
 683   2             // strcpy(str_at,"AT+CMGL=4");
 684   2            //  strcat(uart_buff,ptr);
 685   2              break;
 686   2      
 687   2            case SMS_CMGR:            //读一个短信
 688   2              strcpy(str_at,"AT+CMGR=");
 689   2              strcat(str_at,str_code);
 690   2              break;
 691   2      
 692   2             case SMS_CMGD:           //删除一个短信
 693   2              strcpy(str_at,"AT+CMGD=");
 694   2              strcat(str_at,str_code);
 695   2              break;
 696   2      
 697   2             case AT_CPMS:
 698   2               strcpy(str_at,"AT+CPMS=\x22SM\x22");
 699   2              break;  //AT_CPMS
 700   2      
 701   2           //----------------------------------------------------
 702   2      
 703   2               //----------------------------------------------------------
 704   2      
 705   2           //-----------------------------------------------
 706   2            case AT_COMMAND:
 707   2              break;
 708   2            default:
 709   2              receive_count=0;
 710   2              return(TRUE);
 711   2          }
 712   1          ES=1;
 713   1          strcat(str_at,"\x0d\x00");//在命令后加入CR
 714   1          RI=0;                                       //清除接收标志
 715   1          TI=0;
 716   1         //------------------------------
 717   1          for(i=0;i<MAX_TM;i++)
 718   1              {       if(str_at[i]==0) break;
 719   2                      SBUF=str_at[i];
 720   2                      while(!TI);
 721   2                      TI=0;
 722   2              }
 723   1         //---------------------
 724   1         receive_count=0;
 725   1         str_at[0]=0; str_at[1]=0;str_at[2]=0;
 726   1         i=0; timer_1S_cnt=0;
 727   1         do{
 728   2             dmsec(3);
 729   2             if(receive_count>1)
 730   2             {   //   dmsec(50);
 731   3                  timercount=0; while(timercount<30);
 732   3                  break;
 733   3             }
 734   2      
 735   2          }while(timer_1S_cnt<3);
C51 COMPILER V7.50   CHESHI                                                                04/28/2011 20:11:58 PAGE 13  

 736   1      
 737   1      
 738   1      
 739   1          return(TRUE);
 740   1      
 741   1      
 742   1      
 743   1      }
 744          
 745          
 746          /******************************************/
 747          void main(void)
 748          {
 749   1              uchar i;
 750   1               Sys_Init();
 751   1      
 752   1              Initialize_Model(uart_buff,para_temp);//进行初始化
 753   1       
 754   1      
 755   1              receive_count=0;
 756   1              sms_tmp=0;
 757   1      
 758   1      
 759   1      
 760   1              while(1)
 761   1              {
 762   2                      //-----------查询1到20条中的短信,只要有短信就处理------------------------------------------
 763   2      
 764   2      
 765   2                                      i=read_sms(uart_buff,para_temp,TEL_temp);                       //timer_S_cnt=0;
 766   2                                      if(i==0)
 767   2                                      {
 768   3                                          receive_count=0;
 769   3                                      timer_S_cnt=0; while(timer_S_cnt<60)
 770   3                                      {
 771   4                                                 if(strsearch( "+CMTI:",uart_buff))
 772   4                                                   { break; }
 773   4                                                 if(receive_count>=7)
 774   4                                                    {break; }
 775   4      
 776   4                                      }
 777   3      
 778   3      
 779   3                                      }
 780   2                     else
 781   2                     {
 782   3                         //加入回复短信程序
 783   3      
 784   3                              CMGD_GSM(uart_buff,sms_num_tmp );
 785   3                     }
 786   2      
 787   2      
 788   2      
 789   2      
 790   2      
 791   2              }
 792   1      
 793   1      
 794   1      }
 795          
 796          
 797          
C51 COMPILER V7.50   CHESHI                                                                04/28/2011 20:11:58 PAGE 14  

 798          
 799          
 800          
 801          
 802          
 803          
 804          
 805          
 806          
 807          
 808          
 809          
 810          
 811          
 812          
 813          
 814          
 815          
 816          
 817          
 818          
 819          
 820          
 821          
 822          
 823          
 824          
 825          
 826          
 827          
 828          
 829          
 830          
 831          
 832          
 833          
 834          
 835          
 836          
 837          
 838          
 839          
 840          
 841          
 842          
 843          
 844          
 845          
 846          
 847          
 848          
 849          
 850          
 851          
 852          
 853          
 854          
 855          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2696    ----
C51 COMPILER V7.50   CHESHI                                                                04/28/2011 20:11:58 PAGE 15  

   CONSTANT SIZE    =    173    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     45      54
   IDATA SIZE       =    116       8
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
