 
/*-----------------------------------------------
  内容：连接好串口或者usb转串口至电脑，下载该程序，打开电源
        打开串口调试程序，将波特率设置为9600，无奇偶校验
        晶振11.0592MHz，发送和接收使用的格式相同，如都使用
        字符型格式，设置正确后接受框可以看到UART test 延时循环发送
------------------------------------------------*/
#include <STC15F2K60S2.H>
#include "delay.h"

/*------------------------------------------------
                   函数声明
------------------------------------------------*/
void SendText(unsigned char *text);

/*------------------------------------------------
                    串口初始化
------------------------------------------------*/
void InitUart(void)		//9600bps@11.0592MHz
{
	SCON  = 0x50;		//8位数据,可变波特率
	AUXR |= 0x40;		//定时器时钟1T模式
	AUXR &= 0xFE;		//串口1选择定时器1为波特率发生器
	TMOD &= 0x0F;		//设置定时器模式
	TL1   = 0xE0;		//设置定时初始值
	TH1   = 0xFE;		//设置定时初始值
	ET1   = 0;		    //禁止定时器中断
	TR1   = 1;		    //定时器1开始计时

	//串口接收配置
	EA	  = 1;          //先打开总中断
	ES    = 1;          //再打开串口接收中断
}
                           
/*------------------------------------------------
                    主函数
------------------------------------------------*/
void main (void)
{

	InitUart();

	SendText("Welcome to STC15F2K60S2 UART Demo.\r\n");
	
	while (1)                       
	{
		//接收数据
		//SendText("Sleep ...\r\n");
		
		//延时循环发送
		DelayMs(240);

		DelayMs(240);
	}
}

/*------------------------------------------------
                    发送一个字节
------------------------------------------------*/
void SendTextByte(unsigned char textByte)
{
	SBUF = textByte;

	while(!TI);

	TI = 0;
}

/*------------------------------------------------
                    发送一个字符串
------------------------------------------------*/
void SendText(unsigned char *text)
{
	// \0 表示字符串结束标志，//通过检测是否字符串末尾
	while(*text != '\0')
	{
		SendTextByte(*text);

		text++;
	}
}

/*------------------------------------------------
          串口中断程序
------------------------------------------------*/
void ReceiveUartData(void) interrupt 4   //串行中断服务程序
{
	//定义临时变量
	unsigned char tempReceiveData;
	
	//判断是接收中断产生
	if(RI)
	{
		RI=0;                    //标志位清零

		tempReceiveData = SBUF;  //读入缓冲区的值

		SBUF = tempReceiveData;  //把接收到的值再发回电脑端
	}

    //如果是发送标志位，清零
	if(TI)
	{
		TI=0;
	}
} 
